<?php
/**
 * VocabularySpecificMethodsApi
 * PHP version 5
 *
 * @category Class
 * @package  SkosmosClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Skosmos API
 *
 * The Skosmos REST API is a read-only interface to the data stored on the vocabulary server. The URL namespace is the base URL of the Skosmos instance followed by `/rest/v1/`.   Most methods return the data as UTF-8 encoded JSON-LD, served using the `application/json` MIME type. The data consists of a single JSON object which includes JSON-LD context information (in the `@context` field) and one or more fields which contain the actual data. Some methods (`data`) return other formats (RDF/XML, Turtle, RDF/JSON) with the appropriate MIME type.  The API supports Cross-Origin Resource Sharing by setting the Access-Control-Allow-Origin HTTP header to `\"*\"` for all requests.  The API supports the JSONP convention of appending a callback parameter to any URL. The returned data will then be wrapped in a JavaScript function call using the function name provided as the callback parameter value. JSONP wrapped data will be served using the `application/javascript` MIME type.
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.24
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace SkosmosClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use SkosmosClient\ApiException;
use SkosmosClient\Configuration;
use SkosmosClient\HeaderSelector;
use SkosmosClient\ObjectSerializer;

/**
 * VocabularySpecificMethodsApi Class Doc Comment
 *
 * @category Class
 * @package  SkosmosClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class VocabularySpecificMethodsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation vocidDataGet
     *
     * RDF data of the whole vocabulary or a specific concept. If the vocabulary has support for it, MARCXML data is available for the whole vocabulary in each language.
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $format The MIME type of the serialization format, e.g \&quot;text/turtle\&quot; or \&quot;application/rdf+xml\&quot;. If not specified, HTTP content negotiation (based on the Accept header) is used to determine a suitable serialization format from among the available ones. (optional)
     * @param  string $uri URI of the desired concept. When no uri parameter is given, the whole vocabulary is returned instead. (optional)
     * @param  string $lang RDF language code when the requested resource for the MIME type is language specific, e.g. \&quot;fi\&quot; or \&quot;en\&quot;. (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vocidDataGet($vocid, $format = null, $uri = null, $lang = null)
    {
        $this->vocidDataGetWithHttpInfo($vocid, $format, $uri, $lang);
    }

    /**
     * Operation vocidDataGetWithHttpInfo
     *
     * RDF data of the whole vocabulary or a specific concept. If the vocabulary has support for it, MARCXML data is available for the whole vocabulary in each language.
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $format The MIME type of the serialization format, e.g \&quot;text/turtle\&quot; or \&quot;application/rdf+xml\&quot;. If not specified, HTTP content negotiation (based on the Accept header) is used to determine a suitable serialization format from among the available ones. (optional)
     * @param  string $uri URI of the desired concept. When no uri parameter is given, the whole vocabulary is returned instead. (optional)
     * @param  string $lang RDF language code when the requested resource for the MIME type is language specific, e.g. \&quot;fi\&quot; or \&quot;en\&quot;. (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vocidDataGetWithHttpInfo($vocid, $format = null, $uri = null, $lang = null)
    {
        $returnType = '';
        $request = $this->vocidDataGetRequest($vocid, $format, $uri, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vocidDataGetAsync
     *
     * RDF data of the whole vocabulary or a specific concept. If the vocabulary has support for it, MARCXML data is available for the whole vocabulary in each language.
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $format The MIME type of the serialization format, e.g \&quot;text/turtle\&quot; or \&quot;application/rdf+xml\&quot;. If not specified, HTTP content negotiation (based on the Accept header) is used to determine a suitable serialization format from among the available ones. (optional)
     * @param  string $uri URI of the desired concept. When no uri parameter is given, the whole vocabulary is returned instead. (optional)
     * @param  string $lang RDF language code when the requested resource for the MIME type is language specific, e.g. \&quot;fi\&quot; or \&quot;en\&quot;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidDataGetAsync($vocid, $format = null, $uri = null, $lang = null)
    {
        return $this->vocidDataGetAsyncWithHttpInfo($vocid, $format, $uri, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vocidDataGetAsyncWithHttpInfo
     *
     * RDF data of the whole vocabulary or a specific concept. If the vocabulary has support for it, MARCXML data is available for the whole vocabulary in each language.
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $format The MIME type of the serialization format, e.g \&quot;text/turtle\&quot; or \&quot;application/rdf+xml\&quot;. If not specified, HTTP content negotiation (based on the Accept header) is used to determine a suitable serialization format from among the available ones. (optional)
     * @param  string $uri URI of the desired concept. When no uri parameter is given, the whole vocabulary is returned instead. (optional)
     * @param  string $lang RDF language code when the requested resource for the MIME type is language specific, e.g. \&quot;fi\&quot; or \&quot;en\&quot;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidDataGetAsyncWithHttpInfo($vocid, $format = null, $uri = null, $lang = null)
    {
        $returnType = '';
        $request = $this->vocidDataGetRequest($vocid, $format, $uri, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vocidDataGet'
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $format The MIME type of the serialization format, e.g \&quot;text/turtle\&quot; or \&quot;application/rdf+xml\&quot;. If not specified, HTTP content negotiation (based on the Accept header) is used to determine a suitable serialization format from among the available ones. (optional)
     * @param  string $uri URI of the desired concept. When no uri parameter is given, the whole vocabulary is returned instead. (optional)
     * @param  string $lang RDF language code when the requested resource for the MIME type is language specific, e.g. \&quot;fi\&quot; or \&quot;en\&quot;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function vocidDataGetRequest($vocid, $format = null, $uri = null, $lang = null)
    {
        // verify the required parameter 'vocid' is set
        if ($vocid === null || (is_array($vocid) && count($vocid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vocid when calling vocidDataGet'
            );
        }

        $resourcePath = '/{vocid}/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($uri !== null) {
            $queryParams['uri'] = ObjectSerializer::toQueryValue($uri);
        }
        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }

        // path params
        if ($vocid !== null) {
            $resourcePath = str_replace(
                '{' . 'vocid' . '}',
                ObjectSerializer::toPathValue($vocid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/rdf+xml', 'text/turtle', 'application/ld+json', 'application/json', 'application/marcxml+xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/rdf+xml', 'text/turtle', 'application/ld+json', 'application/json', 'application/marcxml+xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vocidGet
     *
     * General information about the vocabulary
     *
     * @param  string $vocid The Skosmos vocabulary id e.g. stw or yso (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SkosmosClient\Model\VocabularyInfo
     */
    public function vocidGet($vocid, $lang = null)
    {
        list($response) = $this->vocidGetWithHttpInfo($vocid, $lang);
        return $response;
    }

    /**
     * Operation vocidGetWithHttpInfo
     *
     * General information about the vocabulary
     *
     * @param  string $vocid The Skosmos vocabulary id e.g. stw or yso (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SkosmosClient\Model\VocabularyInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function vocidGetWithHttpInfo($vocid, $lang = null)
    {
        $returnType = '\SkosmosClient\Model\VocabularyInfo';
        $request = $this->vocidGetRequest($vocid, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SkosmosClient\Model\VocabularyInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vocidGetAsync
     *
     * General information about the vocabulary
     *
     * @param  string $vocid The Skosmos vocabulary id e.g. stw or yso (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidGetAsync($vocid, $lang = null)
    {
        return $this->vocidGetAsyncWithHttpInfo($vocid, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vocidGetAsyncWithHttpInfo
     *
     * General information about the vocabulary
     *
     * @param  string $vocid The Skosmos vocabulary id e.g. stw or yso (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidGetAsyncWithHttpInfo($vocid, $lang = null)
    {
        $returnType = '\SkosmosClient\Model\VocabularyInfo';
        $request = $this->vocidGetRequest($vocid, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vocidGet'
     *
     * @param  string $vocid The Skosmos vocabulary id e.g. stw or yso (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function vocidGetRequest($vocid, $lang = null)
    {
        // verify the required parameter 'vocid' is set
        if ($vocid === null || (is_array($vocid) && count($vocid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vocid when calling vocidGet'
            );
        }

        $resourcePath = '/{vocid}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }

        // path params
        if ($vocid !== null) {
            $resourcePath = str_replace(
                '{' . 'vocid' . '}',
                ObjectSerializer::toPathValue($vocid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vocidGroupsGet
     *
     * Concept groups in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang label language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SkosmosClient\Model\GroupResult
     */
    public function vocidGroupsGet($vocid, $lang = null)
    {
        list($response) = $this->vocidGroupsGetWithHttpInfo($vocid, $lang);
        return $response;
    }

    /**
     * Operation vocidGroupsGetWithHttpInfo
     *
     * Concept groups in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang label language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SkosmosClient\Model\GroupResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function vocidGroupsGetWithHttpInfo($vocid, $lang = null)
    {
        $returnType = '\SkosmosClient\Model\GroupResult';
        $request = $this->vocidGroupsGetRequest($vocid, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SkosmosClient\Model\GroupResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vocidGroupsGetAsync
     *
     * Concept groups in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang label language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidGroupsGetAsync($vocid, $lang = null)
    {
        return $this->vocidGroupsGetAsyncWithHttpInfo($vocid, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vocidGroupsGetAsyncWithHttpInfo
     *
     * Concept groups in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang label language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidGroupsGetAsyncWithHttpInfo($vocid, $lang = null)
    {
        $returnType = '\SkosmosClient\Model\GroupResult';
        $request = $this->vocidGroupsGetRequest($vocid, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vocidGroupsGet'
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang label language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function vocidGroupsGetRequest($vocid, $lang = null)
    {
        // verify the required parameter 'vocid' is set
        if ($vocid === null || (is_array($vocid) && count($vocid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vocid when calling vocidGroupsGet'
            );
        }

        $resourcePath = '/{vocid}/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }

        // path params
        if ($vocid !== null) {
            $resourcePath = str_replace(
                '{' . 'vocid' . '}',
                ObjectSerializer::toPathValue($vocid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vocidIndexGet
     *
     * Initial letters of the alphabetical index
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SkosmosClient\Model\IndexLetters
     */
    public function vocidIndexGet($vocid, $lang = null)
    {
        list($response) = $this->vocidIndexGetWithHttpInfo($vocid, $lang);
        return $response;
    }

    /**
     * Operation vocidIndexGetWithHttpInfo
     *
     * Initial letters of the alphabetical index
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SkosmosClient\Model\IndexLetters, HTTP status code, HTTP response headers (array of strings)
     */
    public function vocidIndexGetWithHttpInfo($vocid, $lang = null)
    {
        $returnType = '\SkosmosClient\Model\IndexLetters';
        $request = $this->vocidIndexGetRequest($vocid, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SkosmosClient\Model\IndexLetters',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vocidIndexGetAsync
     *
     * Initial letters of the alphabetical index
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidIndexGetAsync($vocid, $lang = null)
    {
        return $this->vocidIndexGetAsyncWithHttpInfo($vocid, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vocidIndexGetAsyncWithHttpInfo
     *
     * Initial letters of the alphabetical index
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidIndexGetAsyncWithHttpInfo($vocid, $lang = null)
    {
        $returnType = '\SkosmosClient\Model\IndexLetters';
        $request = $this->vocidIndexGetRequest($vocid, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vocidIndexGet'
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function vocidIndexGetRequest($vocid, $lang = null)
    {
        // verify the required parameter 'vocid' is set
        if ($vocid === null || (is_array($vocid) && count($vocid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vocid when calling vocidIndexGet'
            );
        }

        $resourcePath = '/{vocid}/index/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }

        // path params
        if ($vocid !== null) {
            $resourcePath = str_replace(
                '{' . 'vocid' . '}',
                ObjectSerializer::toPathValue($vocid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vocidIndexLetterGet
     *
     * Concepts for a given letter in the alphabetical index
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $letter an initial letter, or one of the special values \&quot;0-9 or \&quot;!*\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SkosmosClient\Model\IndexConcepts
     */
    public function vocidIndexLetterGet($vocid, $letter, $lang = null)
    {
        list($response) = $this->vocidIndexLetterGetWithHttpInfo($vocid, $letter, $lang);
        return $response;
    }

    /**
     * Operation vocidIndexLetterGetWithHttpInfo
     *
     * Concepts for a given letter in the alphabetical index
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $letter an initial letter, or one of the special values \&quot;0-9 or \&quot;!*\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SkosmosClient\Model\IndexConcepts, HTTP status code, HTTP response headers (array of strings)
     */
    public function vocidIndexLetterGetWithHttpInfo($vocid, $letter, $lang = null)
    {
        $returnType = '\SkosmosClient\Model\IndexConcepts';
        $request = $this->vocidIndexLetterGetRequest($vocid, $letter, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SkosmosClient\Model\IndexConcepts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vocidIndexLetterGetAsync
     *
     * Concepts for a given letter in the alphabetical index
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $letter an initial letter, or one of the special values \&quot;0-9 or \&quot;!*\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidIndexLetterGetAsync($vocid, $letter, $lang = null)
    {
        return $this->vocidIndexLetterGetAsyncWithHttpInfo($vocid, $letter, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vocidIndexLetterGetAsyncWithHttpInfo
     *
     * Concepts for a given letter in the alphabetical index
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $letter an initial letter, or one of the special values \&quot;0-9 or \&quot;!*\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidIndexLetterGetAsyncWithHttpInfo($vocid, $letter, $lang = null)
    {
        $returnType = '\SkosmosClient\Model\IndexConcepts';
        $request = $this->vocidIndexLetterGetRequest($vocid, $letter, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vocidIndexLetterGet'
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $letter an initial letter, or one of the special values \&quot;0-9 or \&quot;!*\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function vocidIndexLetterGetRequest($vocid, $letter, $lang = null)
    {
        // verify the required parameter 'vocid' is set
        if ($vocid === null || (is_array($vocid) && count($vocid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vocid when calling vocidIndexLetterGet'
            );
        }
        // verify the required parameter 'letter' is set
        if ($letter === null || (is_array($letter) && count($letter) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $letter when calling vocidIndexLetterGet'
            );
        }

        $resourcePath = '/{vocid}/index/{letter}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }

        // path params
        if ($vocid !== null) {
            $resourcePath = str_replace(
                '{' . 'vocid' . '}',
                ObjectSerializer::toPathValue($vocid),
                $resourcePath
            );
        }
        // path params
        if ($letter !== null) {
            $resourcePath = str_replace(
                '{' . 'letter' . '}',
                ObjectSerializer::toPathValue($letter),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vocidLabelStatisticsGet
     *
     * Number of labels by language
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SkosmosClient\Model\LabelStatistics
     */
    public function vocidLabelStatisticsGet($vocid, $lang = null)
    {
        list($response) = $this->vocidLabelStatisticsGetWithHttpInfo($vocid, $lang);
        return $response;
    }

    /**
     * Operation vocidLabelStatisticsGetWithHttpInfo
     *
     * Number of labels by language
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SkosmosClient\Model\LabelStatistics, HTTP status code, HTTP response headers (array of strings)
     */
    public function vocidLabelStatisticsGetWithHttpInfo($vocid, $lang = null)
    {
        $returnType = '\SkosmosClient\Model\LabelStatistics';
        $request = $this->vocidLabelStatisticsGetRequest($vocid, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SkosmosClient\Model\LabelStatistics',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vocidLabelStatisticsGetAsync
     *
     * Number of labels by language
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidLabelStatisticsGetAsync($vocid, $lang = null)
    {
        return $this->vocidLabelStatisticsGetAsyncWithHttpInfo($vocid, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vocidLabelStatisticsGetAsyncWithHttpInfo
     *
     * Number of labels by language
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidLabelStatisticsGetAsyncWithHttpInfo($vocid, $lang = null)
    {
        $returnType = '\SkosmosClient\Model\LabelStatistics';
        $request = $this->vocidLabelStatisticsGetRequest($vocid, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vocidLabelStatisticsGet'
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function vocidLabelStatisticsGetRequest($vocid, $lang = null)
    {
        // verify the required parameter 'vocid' is set
        if ($vocid === null || (is_array($vocid) && count($vocid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vocid when calling vocidLabelStatisticsGet'
            );
        }

        $resourcePath = '/{vocid}/labelStatistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }

        // path params
        if ($vocid !== null) {
            $resourcePath = str_replace(
                '{' . 'vocid' . '}',
                ObjectSerializer::toPathValue($vocid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vocidLookupGet
     *
     * Look up concepts by label
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $label the label to look for, e.g. \&quot;cat\&quot; or \&quot;dog\&quot; (required)
     * @param  string $lang search language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SkosmosClient\Model\LookupResults
     */
    public function vocidLookupGet($vocid, $label, $lang = null)
    {
        list($response) = $this->vocidLookupGetWithHttpInfo($vocid, $label, $lang);
        return $response;
    }

    /**
     * Operation vocidLookupGetWithHttpInfo
     *
     * Look up concepts by label
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $label the label to look for, e.g. \&quot;cat\&quot; or \&quot;dog\&quot; (required)
     * @param  string $lang search language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SkosmosClient\Model\LookupResults, HTTP status code, HTTP response headers (array of strings)
     */
    public function vocidLookupGetWithHttpInfo($vocid, $label, $lang = null)
    {
        $returnType = '\SkosmosClient\Model\LookupResults';
        $request = $this->vocidLookupGetRequest($vocid, $label, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SkosmosClient\Model\LookupResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vocidLookupGetAsync
     *
     * Look up concepts by label
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $label the label to look for, e.g. \&quot;cat\&quot; or \&quot;dog\&quot; (required)
     * @param  string $lang search language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidLookupGetAsync($vocid, $label, $lang = null)
    {
        return $this->vocidLookupGetAsyncWithHttpInfo($vocid, $label, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vocidLookupGetAsyncWithHttpInfo
     *
     * Look up concepts by label
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $label the label to look for, e.g. \&quot;cat\&quot; or \&quot;dog\&quot; (required)
     * @param  string $lang search language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidLookupGetAsyncWithHttpInfo($vocid, $label, $lang = null)
    {
        $returnType = '\SkosmosClient\Model\LookupResults';
        $request = $this->vocidLookupGetRequest($vocid, $label, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vocidLookupGet'
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $label the label to look for, e.g. \&quot;cat\&quot; or \&quot;dog\&quot; (required)
     * @param  string $lang search language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function vocidLookupGetRequest($vocid, $label, $lang = null)
    {
        // verify the required parameter 'vocid' is set
        if ($vocid === null || (is_array($vocid) && count($vocid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vocid when calling vocidLookupGet'
            );
        }
        // verify the required parameter 'label' is set
        if ($label === null || (is_array($label) && count($label) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $label when calling vocidLookupGet'
            );
        }

        $resourcePath = '/{vocid}/lookup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($label !== null) {
            $queryParams['label'] = ObjectSerializer::toQueryValue($label);
        }
        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }

        // path params
        if ($vocid !== null) {
            $resourcePath = str_replace(
                '{' . 'vocid' . '}',
                ObjectSerializer::toPathValue($vocid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vocidModifiedGet
     *
     * Modified concepts in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang label language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  float $offset offset of the starting index (optional)
     * @param  float $limit maximum number of concepts to return (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SkosmosClient\Model\ChangedConceptsResult
     */
    public function vocidModifiedGet($vocid, $lang = null, $offset = null, $limit = null)
    {
        list($response) = $this->vocidModifiedGetWithHttpInfo($vocid, $lang, $offset, $limit);
        return $response;
    }

    /**
     * Operation vocidModifiedGetWithHttpInfo
     *
     * Modified concepts in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang label language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  float $offset offset of the starting index (optional)
     * @param  float $limit maximum number of concepts to return (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SkosmosClient\Model\ChangedConceptsResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function vocidModifiedGetWithHttpInfo($vocid, $lang = null, $offset = null, $limit = null)
    {
        $returnType = '\SkosmosClient\Model\ChangedConceptsResult';
        $request = $this->vocidModifiedGetRequest($vocid, $lang, $offset, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SkosmosClient\Model\ChangedConceptsResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vocidModifiedGetAsync
     *
     * Modified concepts in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang label language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  float $offset offset of the starting index (optional)
     * @param  float $limit maximum number of concepts to return (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidModifiedGetAsync($vocid, $lang = null, $offset = null, $limit = null)
    {
        return $this->vocidModifiedGetAsyncWithHttpInfo($vocid, $lang, $offset, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vocidModifiedGetAsyncWithHttpInfo
     *
     * Modified concepts in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang label language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  float $offset offset of the starting index (optional)
     * @param  float $limit maximum number of concepts to return (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidModifiedGetAsyncWithHttpInfo($vocid, $lang = null, $offset = null, $limit = null)
    {
        $returnType = '\SkosmosClient\Model\ChangedConceptsResult';
        $request = $this->vocidModifiedGetRequest($vocid, $lang, $offset, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vocidModifiedGet'
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang label language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  float $offset offset of the starting index (optional)
     * @param  float $limit maximum number of concepts to return (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function vocidModifiedGetRequest($vocid, $lang = null, $offset = null, $limit = null)
    {
        // verify the required parameter 'vocid' is set
        if ($vocid === null || (is_array($vocid) && count($vocid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vocid when calling vocidModifiedGet'
            );
        }

        $resourcePath = '/{vocid}/modified';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }

        // path params
        if ($vocid !== null) {
            $resourcePath = str_replace(
                '{' . 'vocid' . '}',
                ObjectSerializer::toPathValue($vocid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vocidNewGet
     *
     * New concepts in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang label language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  float $offset offset of the starting index (optional)
     * @param  float $limit maximum number of concepts to return (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SkosmosClient\Model\ChangedConceptsResult
     */
    public function vocidNewGet($vocid, $lang = null, $offset = null, $limit = null)
    {
        list($response) = $this->vocidNewGetWithHttpInfo($vocid, $lang, $offset, $limit);
        return $response;
    }

    /**
     * Operation vocidNewGetWithHttpInfo
     *
     * New concepts in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang label language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  float $offset offset of the starting index (optional)
     * @param  float $limit maximum number of concepts to return (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SkosmosClient\Model\ChangedConceptsResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function vocidNewGetWithHttpInfo($vocid, $lang = null, $offset = null, $limit = null)
    {
        $returnType = '\SkosmosClient\Model\ChangedConceptsResult';
        $request = $this->vocidNewGetRequest($vocid, $lang, $offset, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SkosmosClient\Model\ChangedConceptsResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vocidNewGetAsync
     *
     * New concepts in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang label language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  float $offset offset of the starting index (optional)
     * @param  float $limit maximum number of concepts to return (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidNewGetAsync($vocid, $lang = null, $offset = null, $limit = null)
    {
        return $this->vocidNewGetAsyncWithHttpInfo($vocid, $lang, $offset, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vocidNewGetAsyncWithHttpInfo
     *
     * New concepts in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang label language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  float $offset offset of the starting index (optional)
     * @param  float $limit maximum number of concepts to return (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidNewGetAsyncWithHttpInfo($vocid, $lang = null, $offset = null, $limit = null)
    {
        $returnType = '\SkosmosClient\Model\ChangedConceptsResult';
        $request = $this->vocidNewGetRequest($vocid, $lang, $offset, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vocidNewGet'
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang label language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  float $offset offset of the starting index (optional)
     * @param  float $limit maximum number of concepts to return (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function vocidNewGetRequest($vocid, $lang = null, $offset = null, $limit = null)
    {
        // verify the required parameter 'vocid' is set
        if ($vocid === null || (is_array($vocid) && count($vocid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vocid when calling vocidNewGet'
            );
        }

        $resourcePath = '/{vocid}/new';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }

        // path params
        if ($vocid !== null) {
            $resourcePath = str_replace(
                '{' . 'vocid' . '}',
                ObjectSerializer::toPathValue($vocid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vocidSearchGet
     *
     * Finds concepts and collections from a vocabulary by query term
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $query the term to search for e.g. \&quot;cat*\&quot; (required)
     * @param  string $lang language of labels to match, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $type limit search to concepts of the given type, e.g. \&quot;skos:Concept\&quot;; multiple types can be specified as a space-separated list (optional)
     * @param  string $parent limit search to concepts which have the given concept (specified by URI) as parent in their transitive broader hierarchy (optional)
     * @param  string $group limit search to concepts in the given group (specified by URI) (optional)
     * @param  int $maxhits Maximum number of results to return. If not given, all results will be returned. (optional)
     * @param  int $offset offset where to start in ther esult set, useful for paging the result. If not given, defaults to 0. (optional)
     * @param  string $fields space-separated list of extra fields to include in the results. e.g. \&quot;related\&quot; or \&quot;prefLabel\&quot; or any other skos property. (optional)
     * @param  string $unique boolean flag to indicate that each concept should be returned only once, instead of returning all the different ways it could match (for example both via prefLabel and altLabel). (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SkosmosClient\Model\SearchResults
     */
    public function vocidSearchGet($vocid, $query, $lang = null, $type = null, $parent = null, $group = null, $maxhits = null, $offset = null, $fields = null, $unique = null)
    {
        list($response) = $this->vocidSearchGetWithHttpInfo($vocid, $query, $lang, $type, $parent, $group, $maxhits, $offset, $fields, $unique);
        return $response;
    }

    /**
     * Operation vocidSearchGetWithHttpInfo
     *
     * Finds concepts and collections from a vocabulary by query term
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $query the term to search for e.g. \&quot;cat*\&quot; (required)
     * @param  string $lang language of labels to match, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $type limit search to concepts of the given type, e.g. \&quot;skos:Concept\&quot;; multiple types can be specified as a space-separated list (optional)
     * @param  string $parent limit search to concepts which have the given concept (specified by URI) as parent in their transitive broader hierarchy (optional)
     * @param  string $group limit search to concepts in the given group (specified by URI) (optional)
     * @param  int $maxhits Maximum number of results to return. If not given, all results will be returned. (optional)
     * @param  int $offset offset where to start in ther esult set, useful for paging the result. If not given, defaults to 0. (optional)
     * @param  string $fields space-separated list of extra fields to include in the results. e.g. \&quot;related\&quot; or \&quot;prefLabel\&quot; or any other skos property. (optional)
     * @param  string $unique boolean flag to indicate that each concept should be returned only once, instead of returning all the different ways it could match (for example both via prefLabel and altLabel). (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SkosmosClient\Model\SearchResults, HTTP status code, HTTP response headers (array of strings)
     */
    public function vocidSearchGetWithHttpInfo($vocid, $query, $lang = null, $type = null, $parent = null, $group = null, $maxhits = null, $offset = null, $fields = null, $unique = null)
    {
        $returnType = '\SkosmosClient\Model\SearchResults';
        $request = $this->vocidSearchGetRequest($vocid, $query, $lang, $type, $parent, $group, $maxhits, $offset, $fields, $unique);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SkosmosClient\Model\SearchResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vocidSearchGetAsync
     *
     * Finds concepts and collections from a vocabulary by query term
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $query the term to search for e.g. \&quot;cat*\&quot; (required)
     * @param  string $lang language of labels to match, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $type limit search to concepts of the given type, e.g. \&quot;skos:Concept\&quot;; multiple types can be specified as a space-separated list (optional)
     * @param  string $parent limit search to concepts which have the given concept (specified by URI) as parent in their transitive broader hierarchy (optional)
     * @param  string $group limit search to concepts in the given group (specified by URI) (optional)
     * @param  int $maxhits Maximum number of results to return. If not given, all results will be returned. (optional)
     * @param  int $offset offset where to start in ther esult set, useful for paging the result. If not given, defaults to 0. (optional)
     * @param  string $fields space-separated list of extra fields to include in the results. e.g. \&quot;related\&quot; or \&quot;prefLabel\&quot; or any other skos property. (optional)
     * @param  string $unique boolean flag to indicate that each concept should be returned only once, instead of returning all the different ways it could match (for example both via prefLabel and altLabel). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidSearchGetAsync($vocid, $query, $lang = null, $type = null, $parent = null, $group = null, $maxhits = null, $offset = null, $fields = null, $unique = null)
    {
        return $this->vocidSearchGetAsyncWithHttpInfo($vocid, $query, $lang, $type, $parent, $group, $maxhits, $offset, $fields, $unique)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vocidSearchGetAsyncWithHttpInfo
     *
     * Finds concepts and collections from a vocabulary by query term
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $query the term to search for e.g. \&quot;cat*\&quot; (required)
     * @param  string $lang language of labels to match, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $type limit search to concepts of the given type, e.g. \&quot;skos:Concept\&quot;; multiple types can be specified as a space-separated list (optional)
     * @param  string $parent limit search to concepts which have the given concept (specified by URI) as parent in their transitive broader hierarchy (optional)
     * @param  string $group limit search to concepts in the given group (specified by URI) (optional)
     * @param  int $maxhits Maximum number of results to return. If not given, all results will be returned. (optional)
     * @param  int $offset offset where to start in ther esult set, useful for paging the result. If not given, defaults to 0. (optional)
     * @param  string $fields space-separated list of extra fields to include in the results. e.g. \&quot;related\&quot; or \&quot;prefLabel\&quot; or any other skos property. (optional)
     * @param  string $unique boolean flag to indicate that each concept should be returned only once, instead of returning all the different ways it could match (for example both via prefLabel and altLabel). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidSearchGetAsyncWithHttpInfo($vocid, $query, $lang = null, $type = null, $parent = null, $group = null, $maxhits = null, $offset = null, $fields = null, $unique = null)
    {
        $returnType = '\SkosmosClient\Model\SearchResults';
        $request = $this->vocidSearchGetRequest($vocid, $query, $lang, $type, $parent, $group, $maxhits, $offset, $fields, $unique);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vocidSearchGet'
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $query the term to search for e.g. \&quot;cat*\&quot; (required)
     * @param  string $lang language of labels to match, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $type limit search to concepts of the given type, e.g. \&quot;skos:Concept\&quot;; multiple types can be specified as a space-separated list (optional)
     * @param  string $parent limit search to concepts which have the given concept (specified by URI) as parent in their transitive broader hierarchy (optional)
     * @param  string $group limit search to concepts in the given group (specified by URI) (optional)
     * @param  int $maxhits Maximum number of results to return. If not given, all results will be returned. (optional)
     * @param  int $offset offset where to start in ther esult set, useful for paging the result. If not given, defaults to 0. (optional)
     * @param  string $fields space-separated list of extra fields to include in the results. e.g. \&quot;related\&quot; or \&quot;prefLabel\&quot; or any other skos property. (optional)
     * @param  string $unique boolean flag to indicate that each concept should be returned only once, instead of returning all the different ways it could match (for example both via prefLabel and altLabel). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function vocidSearchGetRequest($vocid, $query, $lang = null, $type = null, $parent = null, $group = null, $maxhits = null, $offset = null, $fields = null, $unique = null)
    {
        // verify the required parameter 'vocid' is set
        if ($vocid === null || (is_array($vocid) && count($vocid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vocid when calling vocidSearchGet'
            );
        }
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling vocidSearchGet'
            );
        }

        $resourcePath = '/{vocid}/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($parent !== null) {
            $queryParams['parent'] = ObjectSerializer::toQueryValue($parent);
        }
        // query params
        if ($group !== null) {
            $queryParams['group'] = ObjectSerializer::toQueryValue($group);
        }
        // query params
        if ($maxhits !== null) {
            $queryParams['maxhits'] = ObjectSerializer::toQueryValue($maxhits);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($unique !== null) {
            $queryParams['unique'] = ObjectSerializer::toQueryValue($unique);
        }

        // path params
        if ($vocid !== null) {
            $resourcePath = str_replace(
                '{' . 'vocid' . '}',
                ObjectSerializer::toPathValue($vocid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vocidTopConceptsGet
     *
     * Top concepts of the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $scheme concept scheme whose top concepts to return. If not given, the default concept scheme of the vocabulary will be used. (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SkosmosClient\Model\TopConcepts
     */
    public function vocidTopConceptsGet($vocid, $lang = null, $scheme = null)
    {
        list($response) = $this->vocidTopConceptsGetWithHttpInfo($vocid, $lang, $scheme);
        return $response;
    }

    /**
     * Operation vocidTopConceptsGetWithHttpInfo
     *
     * Top concepts of the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $scheme concept scheme whose top concepts to return. If not given, the default concept scheme of the vocabulary will be used. (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SkosmosClient\Model\TopConcepts, HTTP status code, HTTP response headers (array of strings)
     */
    public function vocidTopConceptsGetWithHttpInfo($vocid, $lang = null, $scheme = null)
    {
        $returnType = '\SkosmosClient\Model\TopConcepts';
        $request = $this->vocidTopConceptsGetRequest($vocid, $lang, $scheme);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SkosmosClient\Model\TopConcepts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vocidTopConceptsGetAsync
     *
     * Top concepts of the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $scheme concept scheme whose top concepts to return. If not given, the default concept scheme of the vocabulary will be used. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidTopConceptsGetAsync($vocid, $lang = null, $scheme = null)
    {
        return $this->vocidTopConceptsGetAsyncWithHttpInfo($vocid, $lang, $scheme)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vocidTopConceptsGetAsyncWithHttpInfo
     *
     * Top concepts of the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $scheme concept scheme whose top concepts to return. If not given, the default concept scheme of the vocabulary will be used. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidTopConceptsGetAsyncWithHttpInfo($vocid, $lang = null, $scheme = null)
    {
        $returnType = '\SkosmosClient\Model\TopConcepts';
        $request = $this->vocidTopConceptsGetRequest($vocid, $lang, $scheme);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vocidTopConceptsGet'
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $scheme concept scheme whose top concepts to return. If not given, the default concept scheme of the vocabulary will be used. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function vocidTopConceptsGetRequest($vocid, $lang = null, $scheme = null)
    {
        // verify the required parameter 'vocid' is set
        if ($vocid === null || (is_array($vocid) && count($vocid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vocid when calling vocidTopConceptsGet'
            );
        }

        $resourcePath = '/{vocid}/topConcepts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }
        // query params
        if ($scheme !== null) {
            $queryParams['scheme'] = ObjectSerializer::toQueryValue($scheme);
        }

        // path params
        if ($vocid !== null) {
            $resourcePath = str_replace(
                '{' . 'vocid' . '}',
                ObjectSerializer::toPathValue($vocid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vocidTypesGet
     *
     * Information about the types (classes) of objects in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SkosmosClient\Model\TypeList
     */
    public function vocidTypesGet($vocid, $lang = null)
    {
        list($response) = $this->vocidTypesGetWithHttpInfo($vocid, $lang);
        return $response;
    }

    /**
     * Operation vocidTypesGetWithHttpInfo
     *
     * Information about the types (classes) of objects in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SkosmosClient\Model\TypeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function vocidTypesGetWithHttpInfo($vocid, $lang = null)
    {
        $returnType = '\SkosmosClient\Model\TypeList';
        $request = $this->vocidTypesGetRequest($vocid, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SkosmosClient\Model\TypeList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vocidTypesGetAsync
     *
     * Information about the types (classes) of objects in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidTypesGetAsync($vocid, $lang = null)
    {
        return $this->vocidTypesGetAsyncWithHttpInfo($vocid, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vocidTypesGetAsyncWithHttpInfo
     *
     * Information about the types (classes) of objects in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidTypesGetAsyncWithHttpInfo($vocid, $lang = null)
    {
        $returnType = '\SkosmosClient\Model\TypeList';
        $request = $this->vocidTypesGetRequest($vocid, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vocidTypesGet'
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function vocidTypesGetRequest($vocid, $lang = null)
    {
        // verify the required parameter 'vocid' is set
        if ($vocid === null || (is_array($vocid) && count($vocid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vocid when calling vocidTypesGet'
            );
        }

        $resourcePath = '/{vocid}/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }

        // path params
        if ($vocid !== null) {
            $resourcePath = str_replace(
                '{' . 'vocid' . '}',
                ObjectSerializer::toPathValue($vocid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vocidVocabularyStatisticsGet
     *
     * Number of Concepts and Collections in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SkosmosClient\Model\VocabularyStatistics
     */
    public function vocidVocabularyStatisticsGet($vocid, $lang = null)
    {
        list($response) = $this->vocidVocabularyStatisticsGetWithHttpInfo($vocid, $lang);
        return $response;
    }

    /**
     * Operation vocidVocabularyStatisticsGetWithHttpInfo
     *
     * Number of Concepts and Collections in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SkosmosClient\Model\VocabularyStatistics, HTTP status code, HTTP response headers (array of strings)
     */
    public function vocidVocabularyStatisticsGetWithHttpInfo($vocid, $lang = null)
    {
        $returnType = '\SkosmosClient\Model\VocabularyStatistics';
        $request = $this->vocidVocabularyStatisticsGetRequest($vocid, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SkosmosClient\Model\VocabularyStatistics',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vocidVocabularyStatisticsGetAsync
     *
     * Number of Concepts and Collections in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidVocabularyStatisticsGetAsync($vocid, $lang = null)
    {
        return $this->vocidVocabularyStatisticsGetAsyncWithHttpInfo($vocid, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vocidVocabularyStatisticsGetAsyncWithHttpInfo
     *
     * Number of Concepts and Collections in the vocabulary
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocidVocabularyStatisticsGetAsyncWithHttpInfo($vocid, $lang = null)
    {
        $returnType = '\SkosmosClient\Model\VocabularyStatistics';
        $request = $this->vocidVocabularyStatisticsGetRequest($vocid, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vocidVocabularyStatisticsGet'
     *
     * @param  string $vocid a Skosmos vocabulary identifier e.g. \&quot;stw\&quot; or \&quot;yso\&quot; (required)
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function vocidVocabularyStatisticsGetRequest($vocid, $lang = null)
    {
        // verify the required parameter 'vocid' is set
        if ($vocid === null || (is_array($vocid) && count($vocid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vocid when calling vocidVocabularyStatisticsGet'
            );
        }

        $resourcePath = '/{vocid}/vocabularyStatistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }

        // path params
        if ($vocid !== null) {
            $resourcePath = str_replace(
                '{' . 'vocid' . '}',
                ObjectSerializer::toPathValue($vocid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
