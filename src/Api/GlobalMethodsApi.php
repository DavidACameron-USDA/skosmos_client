<?php
/**
 * GlobalMethodsApi
 * PHP version 5
 *
 * @category Class
 * @package  SkosmosClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Skosmos API
 *
 * The Skosmos REST API is a read-only interface to the data stored on the vocabulary server. The URL namespace is the base URL of the Skosmos instance followed by `/rest/v1/`.   Most methods return the data as UTF-8 encoded JSON-LD, served using the `application/json` MIME type. The data consists of a single JSON object which includes JSON-LD context information (in the `@context` field) and one or more fields which contain the actual data. Some methods (`data`) return other formats (RDF/XML, Turtle, RDF/JSON) with the appropriate MIME type.  The API supports Cross-Origin Resource Sharing by setting the Access-Control-Allow-Origin HTTP header to `\"*\"` for all requests.  The API supports the JSONP convention of appending a callback parameter to any URL. The returned data will then be wrapped in a JavaScript function call using the function name provided as the callback parameter value. JSONP wrapped data will be served using the `application/javascript` MIME type.
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.24
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace SkosmosClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use SkosmosClient\ApiException;
use SkosmosClient\Configuration;
use SkosmosClient\HeaderSelector;
use SkosmosClient\ObjectSerializer;

/**
 * GlobalMethodsApi Class Doc Comment
 *
 * @category Class
 * @package  SkosmosClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class GlobalMethodsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation dataGet
     *
     * RDF data of the requested concept
     *
     * @param  string $uri URI of the concept whose data to return (required)
     * @param  string $format the MIME type of the serialization format, e.g. \&quot;text/turtle\&quot; or \&quot;application/rdf+xml\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dataGet($uri, $format = null)
    {
        $this->dataGetWithHttpInfo($uri, $format);
    }

    /**
     * Operation dataGetWithHttpInfo
     *
     * RDF data of the requested concept
     *
     * @param  string $uri URI of the concept whose data to return (required)
     * @param  string $format the MIME type of the serialization format, e.g. \&quot;text/turtle\&quot; or \&quot;application/rdf+xml\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dataGetWithHttpInfo($uri, $format = null)
    {
        $returnType = '';
        $request = $this->dataGetRequest($uri, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation dataGetAsync
     *
     * RDF data of the requested concept
     *
     * @param  string $uri URI of the concept whose data to return (required)
     * @param  string $format the MIME type of the serialization format, e.g. \&quot;text/turtle\&quot; or \&quot;application/rdf+xml\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dataGetAsync($uri, $format = null)
    {
        return $this->dataGetAsyncWithHttpInfo($uri, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dataGetAsyncWithHttpInfo
     *
     * RDF data of the requested concept
     *
     * @param  string $uri URI of the concept whose data to return (required)
     * @param  string $format the MIME type of the serialization format, e.g. \&quot;text/turtle\&quot; or \&quot;application/rdf+xml\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dataGetAsyncWithHttpInfo($uri, $format = null)
    {
        $returnType = '';
        $request = $this->dataGetRequest($uri, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dataGet'
     *
     * @param  string $uri URI of the concept whose data to return (required)
     * @param  string $format the MIME type of the serialization format, e.g. \&quot;text/turtle\&quot; or \&quot;application/rdf+xml\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dataGetRequest($uri, $format = null)
    {
        // verify the required parameter 'uri' is set
        if ($uri === null || (is_array($uri) && count($uri) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uri when calling dataGet'
            );
        }

        $resourcePath = '/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($uri !== null) {
            $queryParams['uri'] = ObjectSerializer::toQueryValue($uri);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/rdf+xml', 'text/turtle', 'application/ld+json', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/rdf+xml', 'text/turtle', 'application/ld+json', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation labelGet
     *
     * List of labels for the requested concept
     *
     * @param  string $uri URI of the concept whose labels to return (required)
     * @param  string $lang search language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SkosmosClient\Model\LabelsAndUri
     */
    public function labelGet($uri, $lang = null)
    {
        list($response) = $this->labelGetWithHttpInfo($uri, $lang);
        return $response;
    }

    /**
     * Operation labelGetWithHttpInfo
     *
     * List of labels for the requested concept
     *
     * @param  string $uri URI of the concept whose labels to return (required)
     * @param  string $lang search language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SkosmosClient\Model\LabelsAndUri, HTTP status code, HTTP response headers (array of strings)
     */
    public function labelGetWithHttpInfo($uri, $lang = null)
    {
        $returnType = '\SkosmosClient\Model\LabelsAndUri';
        $request = $this->labelGetRequest($uri, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SkosmosClient\Model\LabelsAndUri',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation labelGetAsync
     *
     * List of labels for the requested concept
     *
     * @param  string $uri URI of the concept whose labels to return (required)
     * @param  string $lang search language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function labelGetAsync($uri, $lang = null)
    {
        return $this->labelGetAsyncWithHttpInfo($uri, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation labelGetAsyncWithHttpInfo
     *
     * List of labels for the requested concept
     *
     * @param  string $uri URI of the concept whose labels to return (required)
     * @param  string $lang search language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function labelGetAsyncWithHttpInfo($uri, $lang = null)
    {
        $returnType = '\SkosmosClient\Model\LabelsAndUri';
        $request = $this->labelGetRequest($uri, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'labelGet'
     *
     * @param  string $uri URI of the concept whose labels to return (required)
     * @param  string $lang search language, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function labelGetRequest($uri, $lang = null)
    {
        // verify the required parameter 'uri' is set
        if ($uri === null || (is_array($uri) && count($uri) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uri when calling labelGet'
            );
        }

        $resourcePath = '/label';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($uri !== null) {
            $queryParams['uri'] = ObjectSerializer::toQueryValue($uri);
        }
        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchGet
     *
     * Search concepts and collections by query term
     *
     * @param  string $query the term to search for e.g. \&quot;cat*\&quot; (required)
     * @param  string $lang language of labels to match, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $labellang language of labels to return, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $vocab vocabulary/vocabularies to limit search to, e.g. \&quot;yso\&quot; or \&quot;yso allars\&quot; (optional)
     * @param  string $type limit search to concepts of the given type(s), e.g. \&quot;skos:Concept\&quot;. (optional)
     * @param  string $parent limit search to concepts which have the given concept (specified by URI) as parent in their transitive broader hierarchy (optional)
     * @param  string $group limit search to concepts in the given group (specified by URI) (optional)
     * @param  int $maxhits Maximum number of results to return. If not given, all results will be returned. (optional)
     * @param  int $offset offset where to start in the result set, useful for paging the result. If not given, defaults to 0. (optional)
     * @param  string $fields space-separated list of extra fields to include in the results. e.g. \&quot;related\&quot; or \&quot;prefLabel\&quot; or any other skos property. (optional)
     * @param  string $unique boolean flag to indicate that each concept should be returned only once, instead of returning all the different ways it could match (for example both via prefLabel and altLabel). (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SkosmosClient\Model\SearchResults
     */
    public function searchGet($query, $lang = null, $labellang = null, $vocab = null, $type = null, $parent = null, $group = null, $maxhits = null, $offset = null, $fields = null, $unique = null)
    {
        list($response) = $this->searchGetWithHttpInfo($query, $lang, $labellang, $vocab, $type, $parent, $group, $maxhits, $offset, $fields, $unique);
        return $response;
    }

    /**
     * Operation searchGetWithHttpInfo
     *
     * Search concepts and collections by query term
     *
     * @param  string $query the term to search for e.g. \&quot;cat*\&quot; (required)
     * @param  string $lang language of labels to match, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $labellang language of labels to return, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $vocab vocabulary/vocabularies to limit search to, e.g. \&quot;yso\&quot; or \&quot;yso allars\&quot; (optional)
     * @param  string $type limit search to concepts of the given type(s), e.g. \&quot;skos:Concept\&quot;. (optional)
     * @param  string $parent limit search to concepts which have the given concept (specified by URI) as parent in their transitive broader hierarchy (optional)
     * @param  string $group limit search to concepts in the given group (specified by URI) (optional)
     * @param  int $maxhits Maximum number of results to return. If not given, all results will be returned. (optional)
     * @param  int $offset offset where to start in the result set, useful for paging the result. If not given, defaults to 0. (optional)
     * @param  string $fields space-separated list of extra fields to include in the results. e.g. \&quot;related\&quot; or \&quot;prefLabel\&quot; or any other skos property. (optional)
     * @param  string $unique boolean flag to indicate that each concept should be returned only once, instead of returning all the different ways it could match (for example both via prefLabel and altLabel). (optional)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SkosmosClient\Model\SearchResults, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchGetWithHttpInfo($query, $lang = null, $labellang = null, $vocab = null, $type = null, $parent = null, $group = null, $maxhits = null, $offset = null, $fields = null, $unique = null)
    {
        $returnType = '\SkosmosClient\Model\SearchResults';
        $request = $this->searchGetRequest($query, $lang, $labellang, $vocab, $type, $parent, $group, $maxhits, $offset, $fields, $unique);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SkosmosClient\Model\SearchResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchGetAsync
     *
     * Search concepts and collections by query term
     *
     * @param  string $query the term to search for e.g. \&quot;cat*\&quot; (required)
     * @param  string $lang language of labels to match, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $labellang language of labels to return, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $vocab vocabulary/vocabularies to limit search to, e.g. \&quot;yso\&quot; or \&quot;yso allars\&quot; (optional)
     * @param  string $type limit search to concepts of the given type(s), e.g. \&quot;skos:Concept\&quot;. (optional)
     * @param  string $parent limit search to concepts which have the given concept (specified by URI) as parent in their transitive broader hierarchy (optional)
     * @param  string $group limit search to concepts in the given group (specified by URI) (optional)
     * @param  int $maxhits Maximum number of results to return. If not given, all results will be returned. (optional)
     * @param  int $offset offset where to start in the result set, useful for paging the result. If not given, defaults to 0. (optional)
     * @param  string $fields space-separated list of extra fields to include in the results. e.g. \&quot;related\&quot; or \&quot;prefLabel\&quot; or any other skos property. (optional)
     * @param  string $unique boolean flag to indicate that each concept should be returned only once, instead of returning all the different ways it could match (for example both via prefLabel and altLabel). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchGetAsync($query, $lang = null, $labellang = null, $vocab = null, $type = null, $parent = null, $group = null, $maxhits = null, $offset = null, $fields = null, $unique = null)
    {
        return $this->searchGetAsyncWithHttpInfo($query, $lang, $labellang, $vocab, $type, $parent, $group, $maxhits, $offset, $fields, $unique)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchGetAsyncWithHttpInfo
     *
     * Search concepts and collections by query term
     *
     * @param  string $query the term to search for e.g. \&quot;cat*\&quot; (required)
     * @param  string $lang language of labels to match, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $labellang language of labels to return, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $vocab vocabulary/vocabularies to limit search to, e.g. \&quot;yso\&quot; or \&quot;yso allars\&quot; (optional)
     * @param  string $type limit search to concepts of the given type(s), e.g. \&quot;skos:Concept\&quot;. (optional)
     * @param  string $parent limit search to concepts which have the given concept (specified by URI) as parent in their transitive broader hierarchy (optional)
     * @param  string $group limit search to concepts in the given group (specified by URI) (optional)
     * @param  int $maxhits Maximum number of results to return. If not given, all results will be returned. (optional)
     * @param  int $offset offset where to start in the result set, useful for paging the result. If not given, defaults to 0. (optional)
     * @param  string $fields space-separated list of extra fields to include in the results. e.g. \&quot;related\&quot; or \&quot;prefLabel\&quot; or any other skos property. (optional)
     * @param  string $unique boolean flag to indicate that each concept should be returned only once, instead of returning all the different ways it could match (for example both via prefLabel and altLabel). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchGetAsyncWithHttpInfo($query, $lang = null, $labellang = null, $vocab = null, $type = null, $parent = null, $group = null, $maxhits = null, $offset = null, $fields = null, $unique = null)
    {
        $returnType = '\SkosmosClient\Model\SearchResults';
        $request = $this->searchGetRequest($query, $lang, $labellang, $vocab, $type, $parent, $group, $maxhits, $offset, $fields, $unique);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchGet'
     *
     * @param  string $query the term to search for e.g. \&quot;cat*\&quot; (required)
     * @param  string $lang language of labels to match, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $labellang language of labels to return, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (optional)
     * @param  string $vocab vocabulary/vocabularies to limit search to, e.g. \&quot;yso\&quot; or \&quot;yso allars\&quot; (optional)
     * @param  string $type limit search to concepts of the given type(s), e.g. \&quot;skos:Concept\&quot;. (optional)
     * @param  string $parent limit search to concepts which have the given concept (specified by URI) as parent in their transitive broader hierarchy (optional)
     * @param  string $group limit search to concepts in the given group (specified by URI) (optional)
     * @param  int $maxhits Maximum number of results to return. If not given, all results will be returned. (optional)
     * @param  int $offset offset where to start in the result set, useful for paging the result. If not given, defaults to 0. (optional)
     * @param  string $fields space-separated list of extra fields to include in the results. e.g. \&quot;related\&quot; or \&quot;prefLabel\&quot; or any other skos property. (optional)
     * @param  string $unique boolean flag to indicate that each concept should be returned only once, instead of returning all the different ways it could match (for example both via prefLabel and altLabel). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchGetRequest($query, $lang = null, $labellang = null, $vocab = null, $type = null, $parent = null, $group = null, $maxhits = null, $offset = null, $fields = null, $unique = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchGet'
            );
        }

        $resourcePath = '/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }
        // query params
        if ($labellang !== null) {
            $queryParams['labellang'] = ObjectSerializer::toQueryValue($labellang);
        }
        // query params
        if ($vocab !== null) {
            $queryParams['vocab'] = ObjectSerializer::toQueryValue($vocab);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($parent !== null) {
            $queryParams['parent'] = ObjectSerializer::toQueryValue($parent);
        }
        // query params
        if ($group !== null) {
            $queryParams['group'] = ObjectSerializer::toQueryValue($group);
        }
        // query params
        if ($maxhits !== null) {
            $queryParams['maxhits'] = ObjectSerializer::toQueryValue($maxhits);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($unique !== null) {
            $queryParams['unique'] = ObjectSerializer::toQueryValue($unique);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation typesGet
     *
     * Information about the types (classes) of objects contained in all  vocabularies
     *
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (required)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SkosmosClient\Model\TypeList
     */
    public function typesGet($lang)
    {
        list($response) = $this->typesGetWithHttpInfo($lang);
        return $response;
    }

    /**
     * Operation typesGetWithHttpInfo
     *
     * Information about the types (classes) of objects contained in all  vocabularies
     *
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (required)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SkosmosClient\Model\TypeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function typesGetWithHttpInfo($lang)
    {
        $returnType = '\SkosmosClient\Model\TypeList';
        $request = $this->typesGetRequest($lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SkosmosClient\Model\TypeList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation typesGetAsync
     *
     * Information about the types (classes) of objects contained in all  vocabularies
     *
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function typesGetAsync($lang)
    {
        return $this->typesGetAsyncWithHttpInfo($lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation typesGetAsyncWithHttpInfo
     *
     * Information about the types (classes) of objects contained in all  vocabularies
     *
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function typesGetAsyncWithHttpInfo($lang)
    {
        $returnType = '\SkosmosClient\Model\TypeList';
        $request = $this->typesGetRequest($lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'typesGet'
     *
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function typesGetRequest($lang)
    {
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling typesGet'
            );
        }

        $resourcePath = '/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/ld+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/ld+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vocabulariesGet
     *
     * Available vocabularies
     *
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (required)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SkosmosClient\Model\VocabularyList
     */
    public function vocabulariesGet($lang)
    {
        list($response) = $this->vocabulariesGetWithHttpInfo($lang);
        return $response;
    }

    /**
     * Operation vocabulariesGetWithHttpInfo
     *
     * Available vocabularies
     *
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (required)
     *
     * @throws \SkosmosClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SkosmosClient\Model\VocabularyList, HTTP status code, HTTP response headers (array of strings)
     */
    public function vocabulariesGetWithHttpInfo($lang)
    {
        $returnType = '\SkosmosClient\Model\VocabularyList';
        $request = $this->vocabulariesGetRequest($lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SkosmosClient\Model\VocabularyList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vocabulariesGetAsync
     *
     * Available vocabularies
     *
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocabulariesGetAsync($lang)
    {
        return $this->vocabulariesGetAsyncWithHttpInfo($lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vocabulariesGetAsyncWithHttpInfo
     *
     * Available vocabularies
     *
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vocabulariesGetAsyncWithHttpInfo($lang)
    {
        $returnType = '\SkosmosClient\Model\VocabularyList';
        $request = $this->vocabulariesGetRequest($lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vocabulariesGet'
     *
     * @param  string $lang language of labels, e.g. \&quot;en\&quot; or \&quot;fi\&quot; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function vocabulariesGetRequest($lang)
    {
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling vocabulariesGet'
            );
        }

        $resourcePath = '/vocabularies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
